1. Initialise a git repo and push the code onto the git
Reference: https://www.freecodecamp.org/news/git-push-local-branch-to-remote-how-to-publish-a-new-branch-in-git/
git init
git branch -m master main
git add .
git commit -m "episode-01"
git remote add origin https://github.com/ankitadk/Namaste-React.git
git remote -v
git pull origin main
git pull origin main --allow-unrelated-histories
git push origin main
git status

2. Install npm
npm init

3. Install Parcel - it is a bundler
npm install -D parcel => install parcel as a dev dependency since not needed on production
npx parcel index.html
Error
deleted node_modules folder and reinstalled npm using below command
npm install
npx parcel index.html => creates a dev build and hosts our app onto the local server [link: http://localhost:1234]

npm=> install a package
npx=> execute a package

Using cdn links is not a good way to use react library in our project.
Bcoz network calls are very costly. 
We can easily use it if it is already present in our node_modules and we do not wish to make any network calls.
We need to change cdn links if we need to use the upgraded version of the library.

4. Intsall react in our project
npm install react
npm i react-dom

Parcel:
-created a dev build
-created a local server
-it does HMR => hot module replacement since it uses File Watching Algorith (written in c++)
-it does caching for faster builds
-it does image optimization - most expensive work for a browser is loading images
-in case of production build it does the file minification
-bundling
-file compression so that the size is reduced
-consistent hashing
-code splitting
-differential bundling - to support older browsers
-Error handling
-HTTPs
-Tree Shaking - removes unused code

5. creating a production ready app using parcel
npx parcel build index.html

6. add browser compatibility in package.json file
  "browserslist": [
    "last 2 versions"
  ]
  
7. add scripts to package.json to create a dev and prod build
"start": "parcel index.html",
"build": "parcel build index.html",

npm run start => create dev build [npx parcel index.html]
npm start => short cut to create dev build [npx parcel index.html]
npm run build => create production build [npx parcel build index.html]


React syntax is very clumsy hence React developers created JSX 
JSX is not a part of React.
JSX and React are different.
JSX has HTML like syntax and it is not HTML inside JS.
In JSX, attributes are written using CamelCase.
If JSX code occupies multiple lines then wrap the code in circular brackets.

VS Code Extentions:
Better Comments
ESLint
Bracket Pair Coloriser
Prettier

Babel transpiles JSX to React.createElement. React element is converted to an object and then this object is rendered onto the browser as an HTML element.

React Component:
A function that returns some piece of JSX or a React element is a functional component.

Component Composition:
Putting a component inside a component is known as a Component Composition.

JSX takes care of injection attacks and cross site scripting since it is sanitizing the data.

episode 5: lets get hooked
-create a proper folder structure.
-create src folder in the root and move App.js inside it.
-components folder will have all the components.

Two types of exports and imports
-Default Export/import
-Named export/import

Note: Keep ur component code upto 100-200 lines.

-React Hooks
Normal JS utility functions
-useState()
-useEffect()

Note: Whenever a state variable changes React will find the difference between actual DOM and the virtual DOM and it re-renders the component.
Note: React is fast because it is good at DOM manipulation.

React Algorithm:
React uses Reconciliation algorithm also known as React Fiber.
Virtual DOM is a representation of actual DOM. It is a normal JavaScript object.
If I filter my UI to show 3 cards from 7 cards.
Algorithm compares the new object with the old one and then finds the div and updates the DOM.
React Fiber Architecture
Incremental Rendering => the ability to split rendering work into chunks and spread it out over multiple frames.

Episode-06 => Exploring the World
Monolith and Microservice architecture
Single Responsibility Principle
Separation of Concern
In case of Microservice architecture, we can build different services using different tech stacks.

Conditional Rendering
-Rendering UI on basis of some conditions.

Note: Whenever a state variable changes, React triggers a reconciliation cycle and re-renders a component.

Episode-07 => Finding the Path
Install JavaScript library i.e. React Router DOM
Command: npm i react-router-dom

1. create a configuration using createBrowserRouter.
2. Provide the routing configuration to the app using RouterProvider component.
3. Create error component and log errors using useRouteError hook.
3. Create routes
4. Create children routes

createBrowserRouter component creates a routing configuration for us.
RouterProvider component is used to provide the routing configuration to our app.
useRouteError hook can be used to give more info about the error.
Outlet component is used to load a child component. Outlet is filled with a child component according to the path.

Two types of routing in web apps:
1. Client side routing: Components are already loaded. We are not fetching a new page every time we click on any link.
Such apps also known as SPA coz app consists of a single page, just the components getting interchanged via client side routing.
2. Server side : We need to make a server call to load a component.

use useParams hook to extract and use the params from the url.

Episode-08 => Let's Get Classy

React Life cycle is applicable only to Class based components and not the functional components.
React is a Single Page Application and onclick of any link we are just changing the component.
There are a lot of things we need to clear while leaving a page like resources used by setInterval() because in case of SPAs app is not reloaded which is why we need to use unmount to cleanup the memory.
We can use return function in useEffect to clear the memory (while unmounting).
return () => {
 console.log("useEffect return");
}

Research about:
constructor(props)
super(props)
why do we write async componentDidMount?
why cant we write asynch in useEffect callback function : useEffect(async ()=>{}, [])?

